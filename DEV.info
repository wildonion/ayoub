



https://www.lpalmieri.com/posts/2019-12-01-taking-ml-to-production-with-rust-a-25x-speedup/
https://www.lpalmieri.com/posts/2020-09-27-zero-to-production-4-are-we-observable-yet/
https://www.lpalmieri.com/posts/fast-rust-docker-builds/
https://www.lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/
https://www.lpalmieri.com/posts/zero-downtime-deployments/
https://www.lpalmieri.com/posts/caching-types-in-a-microservice-architecture/
https://lucumr.pocoo.org/2018/3/31/you-cant-rust-that/
https://lucumr.pocoo.org/2021/11/14/abusing-serde/
https://lucumr.pocoo.org/2022/1/7/as-any-hack/
https://lucumr.pocoo.org/2022/1/6/rust-extension-map/
https://lucumr.pocoo.org/2022/1/30/unsafe-rust/
https://smallcultfollowing.com/babysteps/blog/2022/03/29/dyn-can-we-make-dyn-sized/
https://smallcultfollowing.com/babysteps/blog/2022/04/12/implied-bounds-and-perfect-derive/
https://smallcultfollowing.com/babysteps/blog/2022/04/17/coherence-and-crate-level-where-clauses/
https://smallcultfollowing.com/babysteps/blog/2022/06/15/what-it-feels-like-when-rust-saves-your-bacon/
https://smallcultfollowing.com/babysteps/blog/2022/06/27/many-modes-a-gats-pattern/
https://without.boats/blog/
https://docs.rust-embedded.org/book/
https://stackoverflow.com/questions/41081240/idiomatic-callbacks-in-rust
https://stackoverflow.com/questions/27831944/how-do-i-store-a-closure-in-a-struct-in-rust
https://rust-hosted-langs.github.io/book/introduction.html
https://fasterthanli.me/articles/peeking-inside-a-rust-enum
https://dhghomon.github.io/easy_rust/Chapter_1.html
https://www.youtube.com/watch?v=mwuCMDSZdiQ&ab_channel=ErikDotDev
https://bparli.medium.com/adventures-in-rust-and-load-balancers-73a0bc61a192
https://github.com/jsdw/weave
https://github.com/hyperium/hyper/blob/master/examples/http_proxy.rs
https://github.com/hyperium/hyper/blob/master/examples/gateway.rs
https://dzone.com/articles/rust-based-load-balancing-proxy-server-with-async
https://truelayer.com/blog/grpc-load-balancing-in-rust
https://medium.com/load-balancer-series/writing-a-http-load-balancer-in-python-using-tdd-theoretical-concepts-fb6dab3e879b
https://kemptechnologies.com/load-balancer/load-balancing-algorithms-techniques
https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html
https://blog.cloudflare.com/pin-and-unpin-in-rust/
https://fasterthanli.me/articles/pin-and-suffering
https://github.com/NicolasLM/nucleon
https://github.com/bparli/convey
http://zderadicka.eu/hyper-websocket/
https://rustwasm.github.io/docs/book/introduction.html
https://www.youtube.com/watch?v=geovSK3wMB8
https://doc.rust-lang.org/reference/attributes.html
http://gradebot.org/doc/ipur/trait.html
https://cheats.rs/#behind-the-scenes
https://doc.rust-lang.org/beta/unstable-book/language-features/generators.html
https://stackoverflow.com/questions/28127165/how-to-convert-struct-to-u8
https://stackoverflow.com/questions/2490912/what-are-pinned-objects
https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html
https://github.com/zupzup/warp-websockets-example
https://github.com/tokio-rs/tokio/tree/master/examples
https://blog.softwaremill.com/multithreading-in-rust-with-mpsc-multi-producer-single-consumer-channels-db0fc91ae3fa
https://danielkeep.github.io/tlborm/book/
https://cetra3.github.io/blog/implementing-a-jobq/
https://cetra3.github.io/blog/implementing-a-jobq-with-tokio/
https://docs.rs/tokio/1.12.0/tokio/sync/index.html
https://tokio.rs/tokio/tutorial/channels
https://docs.rs/tokio-stream/0.1.7/tokio_stream/
https://doc.rust-lang.org/std/marker/struct.PhantomData.html
https://doc.rust-lang.org/std/pin/index.html
https://doc.rust-lang.org/std/sync/struct.Arc.html
https://doc.rust-lang.org/std/rc/struct.Rc.html
https://doc.rust-lang.org/std/sync/struct.Mutex.html
https://doc.rust-lang.org/std/sync/struct.RwLock.html
https://doc.rust-lang.org/std/cell/struct.RefMut.html
https://doc.rust-lang.org/std/cell/struct.RefCell.html
https://doc.rust-lang.org/std/rc/struct.Weak.html
https://doc.rust-lang.org/std/keyword.dyn.html
https://doc.rust-lang.org/book/ch15-05-interior-mutability.html
https://github.com/wildonion/stomegranate/blob/master/helper_board
https://rust-lang-nursery.github.io/rust-cookbook/intro.html
https://doc.rust-lang.org/nomicon/
https://stackoverflow.com/questions/56445095/how-does-videojs-determine-when-to-use-hls-vs-mp4-video-when-both-sources-are-av#:~:text=MP4%20and%20HLS%20are%20actually,a%20server%20to%20a%20client.
https://docs.peer5.com/guides/production-ready-hls-vod/
https://blog.tempus-ex.com/hello-video-codec/
https://github.com/alordash/newton-fractal
https://nnethercote.github.io/perf-book/title-page.html
https://doc.rust-lang.org/1.30.0/book/2018-edition/ch00-00-introduction.html
https://kerkour.com/rust-fearless-concurrency
https://veykril.github.io/tlborm/
https://rust-cli.github.io/book/
https://nomicon.io/RuntimeSpec/ -> use near design pattern cause it's a sharded based blockchain
https://github.com/Bitdad-Dev/bitzio-nft-near-contracts/blob/master/NEAR.rules -> near design pattern explained 
https://stackoverflow.com/questions/41823321/how-to-get-pointer-offset-of-an-enum-member-in-bytes
https://stackoverflow.com/questions/27324821/why-does-an-enum-require-extra-memory-size
https://docs.tendermint.com/master/
https://fasterthanli.me/articles/remote-development-with-rust-on-fly-io
https://rust-unofficial.github.io/patterns/
https://medium.com/@knoldus/design-patterns-in-rust-programming-e5c5ad6ec1a7
https://book.avr-rust.com/001-introduction.html
https://kerkour.com/rust-functional-programming
https://blog.subnetzero.io/post/building-language-vm-part-01/
https://rust-hosted-langs.github.io/book/
https://opensource.com/article/19/3/rust-virtual-machine
https://medium.com/iridium-vm/so-you-want-to-build-a-language-vm-in-rust-part-09-15d90084002
https://medium.com/clevyio/using-rust-and-nom-to-create-an-open-source-programming-language-for-chatbots-12fe67582af5
https://crates.io/crates/hotham -> VR engine in rust
https://github.com/Bitdad-Dev/bitzio-nft-near-contracts
https://www.i-programmer.info/programming/theory.html
https://www.i-programmer.info/babbages-bag/
https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md#the-misconceptions
https://blog.yoshuawuyts.com/
https://github.com/amqp-rs/lapin
https://docs.krustlet.dev/
https://crates.io/crates/kube
https://stackoverflow.com/a/57894943/12132470 -> return pointer from function
https://stackoverflow.com/questions/37789925/how-to-return-a-newly-created-struct-as-a-reference
https://github.com/wildonion/extrust/tree/master/_docs









===========
TECH NOTES
===========
NOTE - streaming all over the incoming chunks of the file to save them one by one inside a buffer located on the client ram on corruption condition to gather those bytes to form the whole file
NOTE - first allocate some bytes on server ram for the incoming file from the client then on every incoming chunk of the file coming from the client save that chunk into the created file on server from the allocated buffer and seek the cursor to the saved position of the file to resume on reconnecting to the server
NOTE - DRL model to reward validator in PoS pattern based on coiniXerr NFT owners' feedback  
NOTE - sharded blockchain means that every shard is an actor which contains multiple blocks and each will communicates with each other using addr object like passing data by calling a contract method inside block a to another contract method inside the block b asyncly
NOTE - near uses actor based model to call smart contract methods and pass data between them asyncly using their address (Addr object) which means we can have multi threading in wasm file
NOTE - split sequential input (borsh encoded async future object data) data into smaller part or async task (can be a request coming from an opened socket and each opened socket is a client) 
with divide and conquer algorithm to feed into the riker actors (processor will choose a free thread from the pool in just a single core to mutex and lock the task to avoid deadlock inside the selected thread) and solve them in there separately (run on separate threads in a thread pool of each actor) then send the each result asyncly to other actor if needed; by moving the Arc<Mutex<T>> (use Arc::new(&Arc<Mutex<T>>) to clone the arced and mutexed T which T can also be Receiver<T>) betweeen riker actor threads (clone the mutex to move it between threads since the Copy and Clone traits are not implemented for the Mutex and by putting the Mutex in Arc this issue will be fixed) using mpsc channel which T is the result then combine the results and compile the whole method to wasm like simd and rayon
NOTE - we'll divide the sequential data into tasks using divide and conquer algo which will be an async job or a task is a closure with async body which contains heavy computation on some mutable Arc<Mutex<Data>> like querying a db thus every job must get solved in separate thread by joining its scheduled thread containing the job in parallel to the executor and we can communicate between threads of objects using message passing channels like mpsc
NOTE - threadpool app examples: sharding based app like blockchains, riker actors, rayon for simultaneous heavy computations and its wasm bindgen which is handled by the simd design pattern, image processing and 3d design apps
NOTE - it seems that a thread can handle so many task at a time but it's a false fact; due to avoiding dealock and data race condition every single thread can handle a task of type Arc<Mutex<T>> (use Arc::new(&Arc<Mutex<T>>) to clone the arced and mutexed T which T can also be Receiver<T>) at a time but it'll done so fast which it seems that it can handle some many tasks at a time
NOTE - a load balancer will spread the incoming requests from the clients to server nodes and istances based on network infrastructure and server loads
NOTE - we can build a high performence pub-sub (producer(s)-consumer(s)) message broker like kafka and rabbitmq using actors since actors features are: threadpool, async mailbox based on mpsc channels, broadcasting Arc<Mutex<event>> channel based on jobq models like mpsc, scheduling message or event and communicating with other actors
NOTE - shared data state between threads: always borrow in iterating and passing into new scope since rust doesn’t obey any garbage collection rule And In order to pass and share a reference of the encoded type (borsh/serde) between threads the type must be send sync and static across threads
NOTE - actors are objects that contains busty threads inside to solve incoming tasks in multiple threads and send message between other actors asyncly
NOTE - based on Mutext concept we can borrow the data multiple times (multiple immutable ownership) by passing it through mpsc channel but mutate it only once at a time inside a thread
NOTE - actors inside a single code base can communicate through a none socket message passing channel like mpsc but in two different system can communicate with each other through a p2p json rpc (over http2, ws and tcp) calls like near protocol
NOTE - multi threading (job queue), Arc<Mutex<T>> (Send + Sync + 'static) T can also be Receiver<T>
NOTE - the task or event (divided using simd) which must be sent between threads or processes must be Arc<Mutex<Task>> or Send Sync static or have valid lifetime acrorss threads or processes


 









=========================================================
                RIKER ACTOR BASED PROJECTS 
=========================================================
TASK - build an ssl based proxy server/client like v2ray protocols, softether and tor snowflake using hyper and tokio on layer4 based on tcp/udp/grpc/websocket and riker actors to bypass the cencorship using cryptography and networking (ipatables) concepts
TASK - build a load balancer like k8s using cpu task scheduling algos like round robin, vector clock, simd and weighted round robin for ayoub using hyper and tokio on layer 1 and 2 (tcp/udp/grpc/websocket) based on and riker actors (every server instance can handle 144000 requests per second so with our load balance we must be able to spread the requests between each server node efficiently)
TASK - object storage like MinIO and S3
TASK - download/upload manager like IDM/tus.io
TASK - chat app on near chain with tor to pass data through onion routing network
TASK - video codec ((de)compression or (de)serializing) like ffmepg or gstreamer and audio and video streaming, media and data channel using webrtc 
TASK - p2p music player, voice and video streaming based on message brokers (broadcasting) like rabbitmq (kafka) and pub-sub (producer(s)-consumer(s)) and message passing channel protocols like mpsc pattern and k8s based on riker actors
TASK - coiniXerr hash for a transaction and transaction signature, block and merkle root and wallet address using Argon2
TASK - load balancer and vps config using transformers and drl based on human feedback
TASK - an event streaming platform like VoD and FoD protocol like arvancloud based for streaming over video (Vod) chunks using ffmpeg and gstreamer in rust based on hls which is an adaptive bitrate method 
        - convert uploaded videos to hls for multi bitrate conversion
        - create an endpoint api to point where the hls is
        - call the api to load in html5 video tag
        - a file on demand protocol to upload files and return their id






