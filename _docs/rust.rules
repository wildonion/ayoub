Async & Multithreading Rules:
    [+] we can't borrow data inside Arc as mutable if we have a an object in which one of its method has &mut self as its first argument and needs to mutate a field 
    [+] to solve the issue we have to put that object inside a Mutex to share and protect it between multiple threads and mutate by blocking the current thread when calling the lock() method, prevent from being in a dead lock, race condition and shared state situations
    [+] actors removes the need for lock-based synchronization or mutext (mutual exclusion) locking when mutating a data structure by blocking the local thread, instead they communicate with each other through defined messages or events based on message passing protocol like mpsc job queue channel
    [+] thread::spawn() takes a closure and tokio::spawn() takes a future and share it between multiple threads using mpsc job queue channel protocol, thus all the subtypes of the task must be Send + Sync and cloneable
    [+] use 'static lifetime to have a valid lifetime across .await (before and after solving the future), cause futures are Future + Send + 'static and are pinned to memory in order to be solved later thus all variables before and after them must be a variable with a valid lifetime
    [+] rust async feature which is zero cost async programming is not based on event loop or green threads like nodejs, it'll convert async functions and blocks to future object by bounding them to Future trait finally the future can be solved inside a single thread or a thread pool using either join!() macro, block_on function or .await
    [+] we can't have async function inside a trait cause traits (usually object safe traits) don't have fixed size at compile time thus we can't pin their async function into memory to create a future since futures will be solved later by suspending the execution using .await  
    [+] closures and object safe traits are not bounded to trait Sized thus their size are unknown at compile and need runtime information to get their own size at runtime so they can't be pinned into the memory thus we can't use them as a future object by putting the async before them cause futures need to be pinned somewhere in ram to be solved later
    [+] futures do nothing unless we call .await on them or poll them and await can only be used inside an async block of function
    [+] when we put the async keyword behind a block or function means we're implementing Future<Output = ()> trait for them and turn them into a Future object and the outpute depends on the return type of that function or block
    [+] block_on will run a future to completion on the current thread and block the thread (execution gets stuck there) until the given future has completed (release the mutex)
    [+] .awaiting a future will suspend the current function's execution until the executor has run the future to completion means doesn't block the current thread, allowing other tasks to run if the future is currently unable to make progress
    [+] join!() is like .await but can wait for multiple futures concurrently, completing multiple futures at the same time
    [+] async codes will not be run immediately, but will only be evaluated when the returned future is .awaited
    [+] Future is an asynchronous version of Result and is solved by awaiting on them
    [+] Stream is an asynchronous version of Iterator and is solved using while let Ok(Some(data)) = payload.next().await
    [+] every type that is bounded to Future trait can be written as: async {} or async move {} async fn some_name(){}
    [+] we'll pin the pointer of the Future object into memory cause we want to await on it later thus it shouldn't move from the memory by replacing with and pointing to a new value of a new variable
    [+] threads can communicate through channels using sender and receiver like mpsc and actors through their address (Addr object) using defined events 
    [+] communication between threads is done using mpsc channel and end of the channel can only be owned by one thread at the time, however the sender half can be cloned and through such cloning the conceptual sender part of a channel can be shared among threads which is how you do the multi-producer, single-consumer part
    [+] we pinned the pointer of the Future object into memory cause we want to await on it later thus it shouldn't move from the memory by replacing with and pointing to a new value of a new variable
    [+] type PFuture = Pin<Box<dyn Future<Output = Result<ServiceResponse, Error>>>>; is a wrapper around a kind of pointer which makes that pointer "pin" its value in place(stack or heap), preventing the value referenced by that pointer from being moved unless it implements  
    [+] running multiple jobs of multiple threads using messaging channel protocol in a single processor at the same time is called multithreading
    [+] worker or threads are working on a single task or job at a time and in multiple producers and single consumer using mpsc channel to send a value between multiple tokio tasks we can clone the sender per task but only have one receiver. 
    [+] in multithreading threadpool diagram every worker (thread) inside the pool will communicate through the messaging channel (the sender and the receiver) protocol for task scheduling process
    [+] multiple producers or workers own the receiver (Arc<T>) and single consumer or worker get the job at a time from the receiver (Mutex<T>)
    [+] for each request comming from the client there is only one thread to do the job (request) at a time
    [+] there are no two threads handling a same job (request) at a time
    [+] there is only one thread get the job after it received it from the channel and it'll lock on that job until it's over, in that moment for the new incoming request another thread must handle the job and send the response
    [+] Arc<T> allows to have multiple ownership of the data which can't implement the Clone trait by cloning it and Mutex<T> allows to lock the thread on the data to mutate its content in multithreading context
    [+] none thread blocking execution between tasks or functions inside a single thread is called async programming
    [+] to do thread safe ops we can share the ownership across multiple threads using Ac<T> and mutate them using only one thread at a time with Mutex<T>
    [+] a Mutex<T> does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available. 
    [+] in order to share the data type (ownership) between threads the Send trait must be implemented for the data type.
    [+] in order to share multiple references of the data type between threads the Sync trait must be implemented for the data type.
    [+] Arc<T> and Mutex<T> are used in multithreading context with Send and Sync traits and RefCell<T> and Rc<T> are used in single threading context without Send and Sync traits
    [+] trait Send and Sync are not implemented for Rc<T> and RefCell<T> because if you clone an Rc<T> value and try to transfer ownership of the clone to another thread, both threads might update the reference count at the same time cause it can't lock the data type like Mutex<T>
    [+] Arc<T> will implement Send and Sync as long as the T implements Send and Sync and makes it thread safe to have multiple ownership of the same data
    [+] we use Arc<RwLock<T>> to share the ownership (clone) of the data type between threads and allow number of threads to read or at most allow one thread to write at any point in time.
    [+] impl Send (for traits and types) and Sync (for references) for all subtypes of the struct to move it between threads like db connections and AI models
    [+] Rc<T> allows to have multiple ownership of the data by cloning it and RefCell<T> allows to keeps track of referencing to the data and mutate its content one at a time in a single thread context
    [+] we can’t just pass the receiver between multiple threads cause trait Clone which is a super trait of Copy is not implemented for the receiver thus we can’t clone it cause if a type is Copy its Clone needs to return *self.
    [+] generally can't clone a data structure unless the trait Clone is implemented for that otherwise in order to move it between threads we have to clone it using Arc.
    [+] the receiver of tokio mpsc channel is shareable between tokio::spawn() threads so we don’t need to take an atomic reference and put it inside the Mutex.
    [+] multiple producer means multiple threads own the receiver and single consumer means only one of them can mutate and get the job or task from the receiver at a time.
    [+] we have to take an atomic reference from the receiver using Arc in order to clone it for passing between multiple threads and for mutating it we have to put it inside a Mutex to insure that only one thread can change the content of the receiver at a time. this is done by waiting on the receiver until a job or task becomes available to down side of the channel then locking on the receiver to acquire the mutex.
    [+] thread safe coding is about to putting the shareable receiver (cloned with Arc) inside a Mutex in order to lock on the incoming task from the sender to prevent other threads from mutating the task at a time.
Sugar Rules:
    [+] 4 bits -> 1 hex and 8 bits -> 2 hex -> 1 byte and 256 bits -> 64 hex -> 32 bytes 
    [+] we can use as_ref() method on Options to borrow the content inside the Option instead of using clone() method
    [+] as_ref() method prevent from moving and make a copy from the original type inside the wrapped type like Option, Arc or Result
    [+] as_ref() converts what's inside a wrapper (an &Option or &Arc or &Result) to &T and living the original types in place
    [+] utf8 bytes (&[u8]) is on range 0 to 255 in which we can represent image pixels or code ascii char instead; utf16 or utf32 support more range of code ascii chars
    [+] raw pointers * and references &T function similarly, but references are always safe because they are guaranteed to point to valid data and it's not a dangling reference due to the borrow checker
    [+] one byte or 00000000 or 0x00 - every 4 digits in one byte is a hex number and every 3 digit in one byte is a oct number
    [+] 32 bytes means 256 bits and 64 characters cause every 4 digits in one byte represents one digit in hex thus 00000000 means 0x00 which is 2 characters in hex and 32 bytes hex string means 64 characters
    [+] one byte is the range 00000000 - 11111111 in binary, or 0x00 - 0xFF in hex, one byte is represented in hex as a 2 character string therefore, a 32 byte hex string is 64 characters long
    [+] the size of a unit struct like Test (std::mem::size_of::<Test>()) is 0
    [+] a codec is basically an algorithm which will map or deserialize the buffer filled of utf8 bytes from memory into an object and visa versa
    [+] there is no way for the compiler to guarantee that you always read the correct type (that is, the most recently written type) from the union
    [+] enums use some extra memory to keep track of the enum variant, with unions we keep track of the current active field ourself
    [+] all fields of a union share common storage and writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field
    [+] usize gives you the guarantee to be always big enough to hold any pointer or any offset in a data structure  and its size is depended on how much size it takes to reference any location in memory, on a 32 bit target usize is 4 bytes and on a 64 bit target usize is 8 bytes, while u32 can be too small on some architectures
    [+] procedural macros enables other prgrammers to use our trait on our own struct
    [+] macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type
    [+] function gets called at runtime and a trait needs to be implemented at compile time
    [+] for those types specially concrete types like traits which don't have size at compile time means they are not bounded to Sized trait, we have to point them using a pointer like Box<dyn Trait> or &dyn Trait
    [+] into_something methods consumes self, avoiding clones as much as possible, and to_something takes &self, potentially cloning some data
    [+] web::Payload in actix is used to extract the streaming of binary data from the request
    [+] we can’t copy the heap allocated data cause if a data with a large length and capacity is gonna be on the heap the copy of that data will face us into a runtime performance issue
    [+] since compiler will free the memory once the heap allocated data get dropped as soon as their scope is finish; we can’t copy the heap allocated data despite the unknown size of them in compile time cause by coping we have two pointers pointing to a same location inside the heap and by dropping the data from the heap we’ll have two dangling pointers pointing to no where which will face us into a double free pointer issue
    [+] ptr, len and capacity (extract them using into_raw_parts() + build the variable using from_raw_parts() ) of a variable will be stored on the stack and if the data was bounded to Sized trait its value will be stored on the stack too otherwise on the heap
    [+] ptr, len and capacity of the String are stored on the stack and the data will be stored on the heap which is a buffer allocate in the binary to the str data cause String is a wrapper around the str
    [+] String is of type Vec<u8> which will be coerced to &[u8] at runtime and every 8 bits is 1 byte so every char in String can be 1 byte in range utf8 means 0 to 255 and byte indices is string slices or &str to some parts of the String
    [+] we use string slices (&Some_String[0..n] for example) to access some parts of the String cause some char might be 2 bytes long thus we can't access them like &Some_String[0] cause the first char is 2 bytes means it's of type utf16
    [+] &String is a pointer to the whole String and a wrapper over a Vec<u8> and &str is a pointer to that part of the String (which is a str) on the heap buffer
    [+] String is a growable, ownable heap-allocated data structure that owns the actual full str buffer on the heap it manages and it can be coerced to a &str
    [+] &str substrings (a slice of String) are just fat pointers to that buffer (allocated by String) on the heap
    [+] a String wraps and manages a dynamically allocated str as backing storage since str cannot be resized, String will dynamically allocate/deallocate memory
    [+] a &str is thus a reference directly into the backing storage of the String, while &String is a reference to the “wrapper” object
    [+] &str can be used for substrings, i.e. they are slices, a &String references always the whole string (a reference to the whole “wrapper” object)
    [+] it was str at first and because of its unknown size, String was created to store the str on the heap and &str is a reference to that heap
    [+] passing heap variables like String to function require to be clonned in order to use them later on cause by passing them through the function their lifetime and ownership get dropped
    [+] using & in function parameters or struct members requires lifetime parameter to prevent from dangling pointer issue so lifetime are specified when a struct or a function is holding a reference to a value
    [+] returning references need lifetime like returning &'static [u8] in function signature cause once functions are executed, they are popped off the execution stack and resources are de-allocated
    [+] the only place that we can return a reference from the function is inside the struct method using &self to return a field owned by the struct not the method itself like returning &self.name
    [+] returning a refernce to a variable like x which is owned by the function or the scope is not safe because that variable will be dropped at the end of the block and the reference &x will be pointing to some garbage data which is a dangling pointer
    [+] we aren't allowed to use a reference beyond how long the referred-to value is valid at its current memory location, means can't return a reference to a variable owned by the function cause the variable the reference is beyond the variable lifetime at its current memory location
    [+] once the program is ran there are limited size of the memory is allocated for the code called buffer and for each variable definition the stack will pop the old one after it's done with its lifetime and push the new one in the location of the old one, in order the value of that variable doesn't move or be a pointable value by a pointer such as Box we need to pin it into the stack or the heap
    [+] in order to stain the value of a variable inside the stack which is referenced by a pointer we have to pin that pointer like Pin<P> which it's pointing to the memory location of that variable meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped
    [+] closures are lazy and do nothing unless called and compiler doesn’t know how much space it will need to store the closure so in order to return the closure in function signature we must put the closure inside the Box<dyn> or use &dyn
    [+] when we use dyn inside the box an object safe trait or closure after that must come cause they are not bounded to trait Sized and we don't know what type we are implementing this trait for
    [+] Vec<&dyn Fn(i32) -> i32> is a vector of i32 closures because Fn is an object safe trait which is not bounded to Sized trait means compiler doesn't know how much space it will need to store the closure thus we must get a reference to Fn using &dyn or Box<dyn Fn(i32) -> i32>
    [+] Fn, FnMut, and FnOnce can be bounded an object safe trait bounds to closure arguments
    [+] Fn trait is an object safe trait, because of unknown size at compile time it needs to be inside the Box<dyn Trait_Name>
    [+] object safe traits are not bounded to trait Sized thus they need to be inside the Box<dyn Trait_Name>
    [+] &T and &mut T will be coerced into raw pointers *const T or *mut T respectively
    [+] Vec<u8> is coerced to &u8 and String is coerced to &str cause of unknown size (not bounded to Sized trait) for both of them at compile time a reference will be taken from them which contains a pointer to the location of the data inside heap saved on stack along with capacity and len    
    [+] we take a reference from a variable using & which is called smart pointer, by doing this we're borrowing the value of the variable instead of taking its ownership and the reference that just has taken from the variable contains a pointer stored on the stack which is a hex address to the memory location of the data stored on heap or stack.
    [+] a pointer contains a reference to the location address of the data on the heap or stack and we can pin its value in place using Pin to prevent the value from being moved 
    [+] trait Sized is implemented for all types that their size are known at compile time like &str and String but it's not bounded to str cause str has no fixed size at compile time
    [+] dynamically sized types or trait objects which have unknown size at compile time must be inside a Box<dyn Trait> or behind a pointer like &dyn Trait or &str in order the compiler knows the size and the address of them
    [+] if we want to say that T may or may not be Sized we must bound it to ?Sized and pass the variable of that type as a referene cause compiler in this stage can't detect the size so we must take a reference from that variable which the pointer has the length of that type and the address at compile time
    [+] all number values are stored in stack plus the address of the heap pointer of other data structure than numbers like String and Box
    [+] multiple mutable references to the same variable is not ok, because any one who is just reading the data has the ability to affect anyone else’s reading of the data.
    [+] multiple immutable references to the same variable is ok, because no one who is just reading the data has the ability to affect anyone else’s reading of the data.
    [+] keep track of multiple immutable and mutable borrows or owners or references at the same time using Rc<T> and RefCell<T>
    [+] due to the ownership and borrowing rules we can use Rc<T> to count the references or borrowers or owners of a value which the other variable is pointing to the value
    [+] due to the lack of changing the immutable references at runtime we can use RefCell<T> to mutate an immutable value at any point in runtime
    [+] we used RefCell<T> to allow us to mutate contents one in a time inside an Rc<T> using RefCell<Rc<T>> pattern and Mutex<T> to mutate contents inside an Arc<T> using Arc<Mutex<T>> pattern
    [+] Arc<T> provides shared ownership of a value of type T, allocated in the heap, invoking clone on Arc produces a new Arc instance, which points to the same allocation on the heap as the source Arc
    [+] a RwLock<T> will allow any number of readers to acquire the lock as long as a writer is not holding the lock.
    [+] the downgrade method can be used to create a non-owning Weak pointer. A Weak pointer can be upgraded to an Arc, but this will return None if the value stored in the allocation has already been dropped, in other words, Weak pointers do not keep the value inside the allocation alive; however, they do keep the allocation (the backing store for the value) alive.
    [+] a cycle between Arc pointers will never be deallocated. For this reason, Weak is used to break cycles, for example a tree could have strong Arc pointers from parent nodes to children, and Weak pointers from children back to their parents.
    [+] references (a pointer to parent location on memory) taken from parent by children is strong cause multiple children in a graph have one parent and own a single node and if we remove the parent all its references and owners (children) must be dropped.
    [+] references (a pointer to child location on memory) taken from children by parent is Weak (non-owning reference or raw pointer) cause all children have only one parent and if we remove a child, the parent strong reference count shouldn't change due to cyclic reference and memory leak prevention.
    [+] Weak reference are non-owning reference means that by removing a child from the parent we might have dangling and an empty reference from the removed child to the parent pointing to no where (parent)!
    [+] take a reference from parent by children which is a pointer to the location of the parent in memory must be Weak cause if we remove the child which has a reference taken from the parent we'll have a dangling reference (pointer) from (to) parent which is a raw pointer without any owner and the Weak counter of parent will decrease by one! cause the child that was pointing to the pranet is removed.
    [+] imagine crate A defines trait Hash and crate B defines struct Pass, based on orphan rule we can't impl Hash for Pass inside crate C other than those crates because it might be some trait with that name exist inside another crates or our C crate for our struct
    [+] the Hash trait or Pass struct must be local to our crate C means we have to define either the trait Hash or struct Pass inside our crate C or we can wrap around the Pass struct with another struct and impl trait Hash for it inside our crate C 
    [+] every type is bounded to some traits like Sized, Clone, Future and Display
    [+] we can bound some traits to a type in function signature using where clause like where T : Clone + Display
    [+] we can control the behavior of each type using their methods and by implementing traits for them
    [+] a trait method can be override inside the implementation block of the type means two types can use a same method signatures of the trait but with different body implementation inside each
    [+] clone data structure if you want to move them between threads so trait Clone must be implemented for them otherwise clone them using Arc.
    [+] every Copy type is also required to be Clone and if T: Copy, x: T, and y: &T, then let x = y.clone(); is equivalent to let x = *y;
    [+] when we derive a Copy implementation Clone is also required cause it's a super trait of Copy.
    [+] if neither Copy nor Clone is not implemented for the object by moving it into a function we loose the ownership of the value of that object; we can borrow the ownership by taking a pointer to it using &
    [+] if a type imeplements trait Copy means we can clone it (cause trait Clone is a super trait of Copy) and also assign the variable into another one without losing the ownership of our variable
    [+] if a type doesn't implement trait Copy means that type is a heap allocated structure and we can use either & to borrow its ownership or by clonning it (trait Clone must be imeplemented) and once we've cloned it using clone() method we'll get a Self from the type (like to_owned() method)
    [+] trait Copy is meant to be implemented for "cheap" types, such as u8 in the example. If you write a quite heavyweight type, for which you think a move is more efficient than a copy, make it not impl Copy and impl Clone. Note that in the u8 case, you cannot possibly be more efficient with a move, since under the hood it would probably at least entail a pointer copy -- which is already as expensive as a u8 copy.
    [+] trait Copy is not implemented for &mut T because if we had the Copy trait for them we could have multiple copy of them in every where and they could change the data of what they have borrowed for thus the reference count of each variable would be out of control inside the current thread, those references don't want a copy of data, they want to own and mutate the data inside what they have borrowed thus we can't mutate the variable itself while its mutable pointer is changing the data inside of it
    [+] trait Copy is not implemented for &mut T because we can have only one mutable reference at a time, thus by copying a mutable variable (assuming its on the stack and its size specified on compile time and is bounded to Sized trait) at runtime we'll panic!
    [+] trait Copy is implemented for &T like &String and &str cause we can have multiple immutable references at a time, thus by copying an immutable variable we'll not panic and will borrow them rather than taking their ownership 
    [+] trait Drop is implemented for those type which trait Copy are not implemented for them means is implemented for heap allocated data structure.
    [+] trait Copy is not implemented for the heap allocated data structure cause having two references (immutable, can't have mutable cause they are not allowed at the same time) pointing to a same data on the heap two times at the same time will face a double free pointer issue, means trying to free a part of the memory two times is unsafe.
    [+] trait Copy is not implemented for the heap allocated data structure cause they don't have known fix sized at compile time and are not bounded to Sized trait.
    [+] trait objects must be inside <Box dyn Trait> which is a smart pointer to a memory location on the heap, cause this trait doesn't have any known fixed size at compile time and we don't know for what type we're implementing this trait for thus we have to use the dyn keyword which is called dynamic dispatch in rust and has runtime overhead.
    [+] some of the types in rust are not known at compile time like str, u8 and traits which their size are not known for the compiler until runtime information catch by the compiler and due to this reason we put them inside Box or take a reference from them like &[u8] to get a smart pointer to their memory location and where their data are put in at compile time.
    [+] trait Clone is implemented for those types that their data are on the heap and trait Copy is implemented for those types that their data are on the stack
    [+] changing the value of the varibale using its pointer or its shallow copy and both the pointer and the object must be defined mutable
    [+] making a deep copy from the object is done by cloning the object using clone() method (trait Clone must be implemented) to prevent double free pointer issue from happening
    [+] object safe traits don't return the type that we're implementing the trait for in their methods, means if a trait returns the Self in one of their methods' return type that trait is not object safe trait and also traits with associated methods are not object safe trait
    [+] trait object have runtime overhead due to their implementation on various types at runtime; Sync and Send are unsafe object traits and we have to use unsafe keyword to implement these traits for the type.
    [+] if any method of the trait bounds to a Sized type or have generic type(every types are bounded to Sized trait by default unless we specify the unknown size using ?Sized trait) its methods, that trait is not object safe trait cause trait objects don't know about their implementor type until runtime and also Sized bound is a compile time overhead.
    [+] object safe trait can be implemented for a type using Box<dyn Trait> or &dyn Trait
    [+] when we derive a Copy implementation Clone is also required cause it's a supertrait of Copy.
    [+] trait Clone is an example of none object safe trait cause its implementor types' data are stored on heap and we can't use it like Box<dync Clone> due to the reason that the trait will return the Self in its method, thus it's not safe to use it inside the box for different implementors and by using Clone trait we'll have heavy runtime overhead for big size objects!
Sugar Memories:
    [+] traits, macros, Box<dyn Trait> &dyn Trait, mpsc job queue channel, ptr + len + cap, pointers and clone (deep copy) for borrowing instead of moving the ownership, 
    [+] lifetimes to prevent dangling pointers from returning + every pointer has its own lifetime
    [+] encoder like (de)serializing from or (d)ecoding into utf8 bytes or mapping using union, borsh and serde codec,  
    [+] unsafe from and into raw parts, little and big endian, raw pointers, mutate `a` using its pointer `b` and vice versa
    [+] add features to a module to include it in Cargo when installing that module like { version = "0.14", features = ["full"] } + cargo [features] flag
    [+] associated type and default type parameter and monomorphization for generic type (no runtime cost)
    [+] all rust smart pointers (Rc is unsafe and Send is safe for multithreading contexts)
    [+] Arc<Mutex<Whatever>> in multi thread (thread safe) and whatever object is shreable + sync, send and static for futures
    [+] Rc<RefCell<Whatever>> in single thread (none thread safe) and whatever object is not shreable
    [+] actix actors are based on event driven model in which future object like message events will be transfered by the event handler asynchronously between threads based on an event driven runtime like tokio 
    [+] async write and read from io socket stream and into buffer 
    [+] channel for async signal message and data passing between threads (data must be shareable and clonable)
    [+] in which an event (might be a future object) loop waits for the event to be called and triggered by an event handler specified by the scheduler
    [+] pointer to a variable is pointing to the location of that variable inside the heap or stack
    [+] & is used to borrow the ownership and Copy trait is a shallow copy
    [+] Clone is a deep copy and is used for heap data cause Copy trait is not implemented for them
    [+] pointer is a reference to the location of the variable to borrow the ownership of that variable and prevent from moving
    [+] mutable pointers can mutate the value inisde the variable if and only if the variable and pointer defined mutable
    [+] we can have only one mutable pointer and multiple immutable pointers at the same time
    [+] can't iterate through a tuple with different data types cause the initial address for each type is different and we can't start from the first element address and iterate till the end of the tuple address
    [+] Every references has associated its lifetime and the Rust compiler proves that the usage of the reference never exceed its lifetime. 
    [+] Safe Rust cannot touches dangling reference even by accident.
    [+] &'static means we're borrowing T for the entire lifetime of the process 
    [+] can't return references from the function cause that pointer is ownded by the current function and its lifetime will be dropped once the function return
    [+] if Copy trait wasn't implemented for a data type we can't pass that data by reference and we have to clone it
    [+] solve io streaming of futures using await (none blocking) or block_on() method on each chunk of bytes in while let syntax like while let Ok(chunk) = io_future_bytes.await{}
    [+] use tokio channels like mpsc job queue channel or oneshot for message passing and moving Arc-ed or cloned and Mutex-ed data structures between rust native and tokio::spawn() method (async task spawning method) green threads 
    [+] future objcets will be created by putting async keyword behind functions, blocks and closure bodies and are bounded to Future trait and can be solved using block_on() method, .await keyword and join!() macro (in async function)
    [+] thread::spawn(|| async move{}) and tokio::spawn(async move{}) return a JoinHandle 
    [+] if the trait Copy was implemented for a type means we can move it without loosing its ownership if it wan't we have to clone it using either trait Clone or Arc 
    [+] & will borrow the ownership of the type and needs an specific lifeimte for the entire of the program 
    [+] shared reference can't dereference between threads and we can sovle it using as_ref() method wich converts a &wrapped type into &T
    [+] load balancer distributes incoming client requests among a group of servers, in each case returning the response from the selected server to the appropriate client
    [+] borrowing the Option's content using as_ref() method and mutable reference will borrow the variable as mutable 
    [+] multithreading is about spawning n threads in overall to handle all incoming tasks from a process like evert socket connections inside a free thread by locking the mutex or the task inside a free thread and one task per available thread
    [+] &self is a pointer to all struct fields and mutating the struct fields is done using &mut self (a mutable pointer to struct fields) 
    [+] if you want to add a pointer with lifetime use &'a Type and if you don't want the lifetime use *const Type (raw pointer)
    [+] struct can own its field like there is not pointer to a type like &'s str and we'll pass self to its first parameter method or it can owned a borrowed field like &'s str
    [+] we can solve futures by awaiting on them to solve impl Future<Output=()>
    [+] we have to put the heap data types inside the Box like closures and traits
    [+] pointer to the heap to borrow the data inside the heap cause we don't have a specific size at compile time for the heap data structures
    [+] async message passing (share clonable data) between threads using channels